// сдлать рефреш экрана от тайера 1 раз сек наример
//


// DIscovery - STM8L152C6T6
// plate STM8L151C8

// дисплей OLED 1.3 128x64 pixel


// Алгоритм работы програмыы:

// первоначальная инициализация всех переменных и настройка портов, АЦП и т.п.
// В првую очередь нстройка портов по выдачи управл сиглалов на электронные ключи - все выключить, чтобы в переходный момент не КЗ все там...
// -Возможно показ лого-заставки на экране
// - считывание напряжения на аккумуляторе и показ соответствующего уровня праряжения на пиктограмме индикатора (т.е. при подкл аккумулятора можно оценить его напряжение)
// - и потом полное погасание экрана и через 5 сек переход в ждущий режим энергосбережения (ожидание нажатия кнопки ПУСК).

// Потом - бесконечный цикл:
// -сканирование состояния переключателей подачи 2кВ и кнопки ПУСК
// -сканирование состояния светодиодов (крсн, зел, желт)
// -сканирование всех напряжений АЦП - делается автоматом в связке АЦП-ДМА
// -Если кнопка ПУСК нажата:
	// -проверка напряжений в макс диапазонах, ни одно напряжение не должно быть выше максимального порога
	//сравнение значений АЦП с Хорошими/плохими и установка соответствующих флагов
	// (если какое-либо напряжение, кроме аккум и АСДС, вышло за поле допуска - фиксация ошибки РАБоты, код ошибки - выход напряжения за поле допуска
	// если напряжение на АСДС вышло за пределы допуска И напряжение аккумулятора в допуске - вызов функции преключения с АСДС на акумулятор
	// если напряжение на аккумуляторе вышло за нижний предел допуска И напряж АСДС в допуске И работа от АСДС - вызов функции вкл ЗУ аккумулятора
	// если напряжение на аккумуляторе вышло за нижний предел допуска И напряж АСДС в допуске И работа от Аккум - фиксация ошибки и break
	// если напряжение на аккумуляторе вышло за нижний предел допуска И напряж АСДС не в допуске И работа от Аккум - запуск завершения работы с устройством и break
	
	// -вывод на экран надписи сответвующие текущим статусам переключателей, электронных ключей и пиктрограмму батарейки
	
	// -если старт (флаг старта) не произошел, то запускаем функции старта
		// -если есть напряжение на аккумуляторе в поле допуска:
			// -функция старта на аккумуляторе:
				// -проверка напряжения на аккумуляторе (напряжения до ключа аккумулятора)
				// -если напряжение аккумулятора в поле допуска - запуск функции ВКЛючения электроного ключа Аккумулятора
				// (внутри функции подается управляющий включающий сигнал на электронный ключ и в течении 5 сек контролируются все напряжения,
				// если напряж аккумулятора вышло за поле допуска - фиксация ошибки ЗАПуска на аккумуляторе, код ошибки - выход напряж аккум за границы поля допуска
				// если другое напряжение, которого не должно быть появилось - фиксация ошибки ЗАПуска на аккумуляторе, код ошибки - появление стороннего напряжения
				// если какое-либо напряжение вышло за поле допуска - фиксация ошибки ЗАПуска на аккумуляторе, код ошибки - выход напряжения за поле допуска)
				// -установка флага работы от акуум
		// -если есть напряжение на АСДС в поле допуска:
			// -функция старта на АСДС:
				// -проверка напряжения на АСДС (напряжения до ключа АСДС)
				// -если напряжение АСДС в поле допуска - запуск функции ВЫКЛючения электроного ключа Аккумулятора и запуск функции ВКЛючения электроннго ключа АСДС
				// (внутри функции ВКЛючения подается управляющий включающий сигнал на электронный ключ и в течении 5 сек контролируются все напряжения,
				// если напряж АСДС вышло за поле допуска - фиксация ошибки ЗАПуска на АСДС, код ошибки - выход напряж АСДС за границы поля допуска
				// если другое напряжение, которого не должно быть появилось - фиксация ошибки ЗАПуска на АСДС, код ошибки - появление стороннего напряжения
				// если какое-либо напряжение вышло за поле допуска - фиксация ошибки ЗАПуска на АСДС, код ошибки - выход напряжения за поле допуска)	
				// -установка флага работы от АСДС
		// -если фукнция старта закончилась ошибкой или функция старта на АСДС закончилась ошибкой - вывести код ошибки на экан, выключить все электронные ключи	
		// -если функции старта на Аккум ИЛИ старта на АСДС произошло - установим флаг старта

// -Если кнопка ПУСК не нажата (завершение работы с устройством, пользователь выключил кнопку пуск):
	// - запуск завершения работы с устройством:
		// -отображаем завершающую заставку типа "До свидания"
		// -выключаем все электронные ключи в последовательности - 2кВ, ЗУ, АСДС, Аккум
		// -сбрасываем флаг старта и коды ошибок, флаги работы от аккум или асдс
		// -через 5 сек переходим в энергосберегающий режим (и ждем там нажатия кнопки ПУСК)


#ifndef   _MAIN_H_
#define   _MAIN_H_
 
//#define DEBUG		// работа устройства в тестовом режиме
#define WORK	// работа реального устройства
 
 //#include "stm8l15x_conf.h"
 //#include "stm8l15x_conf.h"
 //#include "stm8l15x.h"
 
  //#include "menu.h"

// назначение пинов микросхемы  в соответствии со схемой электрической принципиальной:


// PA4 - ADC1_IN2 - ADC вход на сигнал 24В системное  на КРОСС
// PA5 - ADC1_IN1 - ADC вход на сигнал 24В первая сторона кнопки СТОП
// PA6 - ADC1_IN0 - ADC вход на сигнал 24В ACDC

// PB0 - LED_Red - вход от светодиода красный, активный уровень высокий
// PB1 - LED_Green - вход от светодиода зеленого, активный уровень высокий
// PB2 - LED_PW - вход от светодиода желтого, питания, активный уровень высокий
// PB3 - Sw_dcdc_2kV - вход от кнопки SW2kV, активный уровень низкий

// PB0 - LED_PW - вход от светодиода желтого, питания, активный уровень высокий
// PB1 - LED_Red - вход от светодиода красный, активный уровень высокий
// PB2 - LED_Green - вход от светодиода зеленого, активный уровень высокий


// PB7 - ON_DCDC2kV_H - выход на включение преобразователя 2кВ
// PB6 - ON_Charge_H -  выход на включение ЗУ Аккумулятора
// PB5 - ON_ACCUM_H - выход на включение Аккумулятора
// PB4 - ON_ACDC_H -   выход на включение ACDC


// PC0 - SDA -I2C- OLED - выход на OLED
// PC1 - SCL -I2C- OLED - выход на OLED

// PC2 - ADC1_IN6 - ADC вход на сигнал +24V Аккумул
// PC3 - ADC1_IN5 - ADC вход на сигнал 5V системное на плату
// PC4 - ADC1_IN3 - ADC вход на сигнал -15V системное на плату
// PC7 -  ADC1_IN4 - ADC вход на сигнал +15V системное на плату

// PC5 - BL_LCD_L - выход на вывод включения питания LCD, активный уровень низкий

// PE0 - Start_L - вход от кнопки пуск


// PD4 - ADC1_IN10 - ADC вход на сигнал токового шунта 11
// PD5 - ADC1_IN9 - ADC вход на сигнал  токового шунта 12
// PD6 - ADC1_IN7 - ADC вход на сигнал вторая сторона кнопки СТОП
// PD7 - ADC1_IN8 - ADC вход на сигнал 24V ЗУ Аккумулятора

//------------------------------------------------------------------------------------
//------------------  настройки входов/выходов ---------------------------------------
//------------------------------------------------------------------------------------

// определение портов
#define PORTA		GPIOA 
#define PORTB		GPIOB 
#define PORTF 		GPIOF  
#define PORTC 		GPIOC 
#define PORTE 		GPIOE 
#define PORTD 		GPIOD  


// PE0 - Start_L - вход от кнопки пуск
// PB3 - Sw_dcdc_2kV - вход от кнопки SW2kV, активный уровень низкий
#define Start_L GPIO_Pin_0			// input key START
#define Sw_dcdc_2kV GPIO_Pin_3		// input key SW2kV

// PB0 - LED_Red - вход от светодиода красный, активный уровень высокий
// PB1 - LED_Green - вход от светодиода зеленого, активный уровень высокий
// PB2 - LED_PW - вход от светодиода желтого, питания, активный уровень высокий
// #define LED_Red GPIO_Pin_0
// #define LED_Green GPIO_Pin_1
// #define LED_PW GPIO_Pin_2
// PB0 - LED_PW - вход от светодиода желтого, питания, активный уровень высокий
// PB1 - LED_Red - вход от светодиода красный, активный уровень высокий
// PB2 - LED_Green - вход от светодиода зеленого, активный уровень высокий
#define LED_Red GPIO_Pin_1
#define LED_Green GPIO_Pin_2
#define LED_PW GPIO_Pin_0

// PA4 - ADC1_IN2 - ADC вход на сигнал 24В системное  на КРОСС
// PA5 - ADC1_IN1 - ADC вход на сигнал 24В первая сторона кнопки СТОП
// PA6 - ADC1_IN0 - ADC вход на сигнал 24В ACDC
#define ADC1_IN2 GPIO_Pin_4
#define ADC1_IN1 GPIO_Pin_5
#define ADC1_IN0 GPIO_Pin_6
// PC2 - ADC1_IN6 - ADC вход на сигнал +24V Аккумул
// PC3 - ADC1_IN5 - ADC вход на сигнал 5V системное на КРОСС
// PC4 - ADC1_IN3 - ADC вход на сигнал -15V системное на КРОСС
// PC7 -  ADC1_IN4 - ADC вход на сигнал +15V системное на КРОСС
#define ADC1_IN6 GPIO_Pin_2
#define ADC1_IN5 GPIO_Pin_3
#define ADC1_IN3 GPIO_Pin_4
#define ADC1_IN4 GPIO_Pin_7
// PD4 - ADC1_IN10 - ADC вход на сигнал токового шунта 11
// PD5 - ADC1_IN9 - ADC вход на сигнал  токового шунта 12
// PD6 - ADC1_IN7 - ADC вход на сигнал вторая сторона кнопки СТОП
// PD7 - ADC1_IN8 - ADC вход на сигнал 24V ЗУ Аккумулятора
#define ADC1_IN10 GPIO_Pin_4
#define ADC1_IN9 GPIO_Pin_5
#define ADC1_IN7 GPIO_Pin_6
#define ADC1_IN8 GPIO_Pin_7



// PB7 - ON_DCDC2kV_H - выход на включение преобразователя 2кВ
// PB6 - ON_Charge_H - выход на включение ЗУ Аккумулятора
// PB5 - ON_ACCUM_H - выход на включение Аккумулятора
// PB4 - ON_ACDC_H - выход на включение ACDC
#define ON_DCDC2kV_H GPIO_Pin_7
#define ON_Charge_H GPIO_Pin_6
#define ON_ACCUM_H GPIO_Pin_5
#define ON_ACDC_H GPIO_Pin_4

// PC5 - BL_LCD_L - выход на вывод включения питания LCD, активный уровень низкий
#define BL_LCD_L GPIO_Pin_5	//выход управление основным питанием LCD




 
//------------------------------------------------------------------------------------
//--------------------- тактовой частоты ядра ----------------------------------------
//------------------------------------------------------------------------------------
#define CLK_SYSCLKDiv CLK_SYSCLKDiv_1 	// SYSCLK=16 MHz
//#define CLK_SYSCLKDiv CLK_SYSCLKDiv_4	// SYSCLK=16/4=4 MHz
//#define CLK_SYSCLKDiv CLK_SYSCLKDiv_8	// SYSCLK=16/8=2 MHz
//#define CLK_SYSCLKDiv CLK_SYSCLKDiv_32	// SYSCLK=16/32=0,5 MHz
//>>#define CLK_SYSCLKDiv CLK_SYSCLKDiv_64	// SYSCLK=16/64=0,25 MHz

#define CLK_SYSCLKDiv_Eco CLK_SYSCLKDiv_1 	// SYSCLK_Eco= 38000 Hz/1 = 38000 Hz   26,3 us 
   
//------------------------------------------------------------------------------------
//------------------  настройки таймеров ---------------------------------------------
//------------------------------------------------------------------------------------   
 // -- @ HSI = 16 MHz
#define TIM4_PERIOD       		124//0xFF //=256 			16MHz/2/TIM4_Prescaler_32768/FF=  100 ms
//#define TIM4_PERIOD       	0x23 //=256/8=35	 	16MHz/2/TIM4_Prescaler_32768/FF=  100 ms
//#define TIM4_PERIOD_delay1		0x33 //=51 			2MHz/2/TIM4_Prescaler_2048/51= 9,57Гц =  104 ms
#define TIM4_PERIOD_delay1		0x19 //=25 			2MHz/2/TIM4_Prescaler_2048/25= 19,5 Гц =  51 ms


//#define TIM2_PERIOD       0x3FFF //=16383  ?????????????250 ms
//#define TIM2_PERIOD       0x7FFE //=32766  261 ms
#define TIM2_PERIOD       0x7A99 //=31385  250 ms

#define TIM2_PERIOD_EcoMode		0x0280	//=640	210us*640=134 ms
  

//#define TIM3_PERIOD       0x2FFF //  100 ms      0x00A3 = 2,5 ms = 400 Hz
// #define TIM3_PERIOD       0x1FFF //  65 ms 
//#define TIM3_PERIOD		 0x0FFF // 32,5 ms
// #define TIM3_PERIOD		 0x01FF // 4 ms

//#define TIM3_PERIOD		 0x007F //=127 			1.36 ms
#define TIM3_PERIOD		 0x0060 //=96 			1 ms
//#define TIM3_PERIOD		 0x000F //=127/8=15 


/* // -- @ LSI = 32768 kHz ( в 488,28 раз меньше относительно 16MHz)
#define TIM4_PERIOD       10
#define TIM2_PERIOD       0x0004 //  250 ms
#define TIM3_PERIOD		 0x0004 // 1 ms  */




//#define TIMER4_Prescaler TIM4_Prescaler_16384
#define TIMER4_Prescaler TIM4_Prescaler_2048
//#define TIMER4_Prescaler TIM4_Prescaler_512
//>>#define TIMER4_Prescaler TIM4_Prescaler_256


#define TIMER2_Prescaler_EcoMode TIM2_Prescaler_8		// 38 kHz/8=4,75 kHz  210us		

//#define TIMER2_Prescaler TIM2_Prescaler_64
#define TIMER2_Prescaler TIM2_Prescaler_8		// 2MHz/8=0,250 MHz  4us
//#define TIMER2_Prescaler TIM2_Prescaler_2
//>>#define TIMER2_Prescaler TIM2_Prescaler_1

//#define TIMER3_Prescaler TIM3_Prescaler_32
#define TIMER3_Prescaler TIM3_Prescaler_4
//#define TIMER3_Prescaler TIM3_Prescaler_1
//>>#define TIMER3_Prescaler TIM3_Prescaler_1


/*------------------------------------------------------------------------------------------------------*/
//I2C
#include "IIC.h"
#define I2C_SPEED 100000


//------------------------------------------------------------------------------------
//------------------  настройки ADC измерителя напряжения батарейки и других напряжений  -----------------
//------------------------------------------------------------------------------------ 

//границы емкостей для отображения полосок внутри батарейки/
// граница в 30% емкости 
#define CapacityBat30per 10000	
// граница в 60% емкости 
#define CapacityBat60per 20000	

#define VminACDC	2200	//	3030	// примерно 22В
#define VmaxACDC	2800	//	3860	// примерно 28В
#define VminACC		2200	//	3030	// примерно 22В
#define VmaxACC		2800	//	3860	// примерно 28В
#define VminCharge	2200	//	3030	// примерно 22В
#define VmaxCharge	2800	//	3860	// примерно 28В


#define VminSys5DC		 480	//		715-36		//-5%
#define VminSys15DC		1425	//		2145-107	//-5%
#define VminSys24DC		2200	//		3432-172	//-5%
								//
#define VmaxSys5DC		 520	//		715+36		//+5%
#define VmaxSys15DC		1575	//		2145+107	//+5%
#define VmaxSys24DC		2600	//		3432+172	//+5%

//------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------

typedef enum {off = 0, on} statSW ;
typedef enum {low = 0, high} statSVD;
typedef enum 
{
	no_error = 0,
	VoltAccum,
	VoltACDC,
	Volt2kV,
	ErrorRedAndGrSVD,
	ErrorYellowSVD,
	ErrorModeWork
} CodeError;

// структура описывающая переключатель на передней панели устройства
typedef struct
{
	statSW	status;		// состояние на текущий момент положения переключателя
	statSW	pre_status;		// состояние на предыдущего положения переключателя
	char 	numlvl;		// числовое значение переключателя
	char  	*txt_eng;		//текст значения переменной на английском
	char  	*txt_rus;		//текст значения переменной на русском 
} Switcher;

// структура описывающая электронный ключ (электронное реле) на плате
typedef struct
{
	statSW	status;		// состояние на текущий момент положения переключателя
	char 	numlvl;		// числовое значение переключателя
	int		numADC;		// значение напряжения до ключа в попугаях АЦП
	float	volt;		// значение напряжениея до ключа в Вольтах
	char  	*txt_eng_ON;		//текст значения переменной на английском при положении ключа в ON
	char  	*txt_rus_ON;		//текст значения переменной на русском  при положении ключа в ON
	char  	*txt_eng_OFF;		//текст значения переменной на английском при положении ключа в OFF
	char  	*txt_rus_OFF;		//текст значения переменной на русском  при положении ключа в OFF
} ElRele;


// структура описывающая светодиод
typedef struct
{
	statSVD	status;		// состояние на текущий момент уровня светодиода
	statSVD	pre_status;		// состояние на предыдущего уровня светодиода
	char 	numlvl;		// числовое значение 
	char  	*txt_eng;		//текст значения переменной на английском
	char  	*txt_rus;		//текст значения переменной на русском 
} SVD;

// структура описывающая ошибки устройства
typedef struct
{
	bool			status;		// состояние ошибки
	CodeError	 	code_error;		// числовое значение 
	char  	*txt_eng;		//текст значения переменной на английском
	char  	*txt_rus;		//текст значения переменной на русском 
} ErrorDevice;

// структура описывающая статус работы устройства - объединение всех флагов в одном месте
struct StatusDev
{
	bool	Start;		// признак состоявшегося старта
	bool 	WorkFromACC;	//флаг  работы устройства от Аккумулятора
	bool 	WorkFromACDC;	//флаг  работы устройства от ACDC
	bool 	WorkCharge;	//флаг  работы ЗУ Аккумулятора
	bool 	Power2kV;		//флаг  работы преобразователя 2кВ
	bool 	TrueVotageACC;	// флаг плохого/хорошего уровня напряжения аккумулятора
	bool 	TrueVotageACDC;	// флаг плохого/хорошего уровня напряжения ACDC
	bool 	TrueVotageCharge;	// флаг плохого/хорошего уровня напряжения ЗУ Аккумулятора
	bool 	TrueVotageSys5DC;	
	bool	TrueVotageSys15DC;	
	bool 	TrueVotageSys24DC;
	bool	RefreshLCD;			// признак того что надо обновить изображение на LCD
	//CodeError	 	code_error;		// числовое значение 
	//char  	*Txt_eng;		//текст значения переменной на английском
	//char  	*Txt_rus;		//текст значения переменной на русском 
};// StatusDevice;


 void delay_100ms(void);
extern void delay_ms(int ms);
extern void delay_us(int us);




#endif
